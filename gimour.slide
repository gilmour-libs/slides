Patterns in Distributed Systems
& how Gilmour addresses those.

Piyush Verma
piyush@piyushverma.net
@meson10

* Microservices

* Why?

Division of organisation/responsibility

Scalability at function point granularity

* Horizontal = Distributed

* High level architecture patterns

* #1 Observer Pattern

.image signal_slot.png

* Observer Pattern characteristics

Also called as Signal & Slots

Broadcast - Fanout

Wildcard topics

Responses disabled

Receivers are responsible for failures.

* #2 Request Reply Pattern

.image request_response.png

* Request Reply characteristics

At least once delivery.

  Ensure there is atleast one Subscriber.

Timeouts

  Client side timeouts.
  Server side timeouts.

Response or Error, guaranteed.

Separate response and error channels.

Distributed Mutual Exclusion

  Subscriber groups

* #3 Service Composition

* Composition Pattern characteristics

Lazy programmer's pipeline.

Coalesce many calls and publish a single cumulative event

compose

  cmd1 | cmd2 | cmd3

andand

  cmd1 && cmd2 && cmd3

batch

  cmd1; cmd2; cmd3 > out
  (cmd1; cmd2; cmd3) > out


* Common Expectations

* Common Expectations [1/2]

Asynchronous messaging

Low latency

  Protocol and communication medium - non-http

Health tracking

  Service Level monitoring
  Node Level availability

High availability

  Service level health

Per message UID

  Ensures uniqueness and data consistency

* Common Expectations [2/2]

Per Request logging

  Easy to parse and analyse logs

Concurrency

  Logical
  Physical
  Distributed.

Fault Diagnosis

  Error broadcasting
  Error queuing
  Error ignoring

* Message exchange protocol

All gilmour services share the same data structure.

Error or response have similar data structure.

Human readable.

* Failure Handling

* Gilmour does not provide failure handling, only failure detection

Health Bulletin [[https://github.com/gilmour-libs/health-bulletin]]

.image missing_topics.png

* Honestly, we really spent a lot of time to decide against it.

.image unreachable_host.png

* Hystrix - per node heuristics

Secondaries

Failovers

Backpressure management

Circuit breaker

* Nice subscribers

Use nice to _avoid_ cascading.

.image nice_subscribers.png

_Can_be_used_with/without_hystix_

* Patterns Gilmour does not handle

* Other Patterns

Load Balancing

  Equal distribution of Load.
  But You could use Nice subscribers to handle this!

Partitioning/Sharding

  Not network partitioning.
  Subset of an event on subscriber registration.
  Use smaller topics instead!

Leader Election

  Ability to select fittest node per message.

Convergecast

  Collate data from all listeners and return together.

* Language Support

* Current implementations

Ruby

  Runs on Event Machine.
  Allows Fork per subscriber.
  Stdout/Stderr hijacking for consolidated logging.

Java

Golang

* Why did we name it gilmour?

Just in case you wondered.
